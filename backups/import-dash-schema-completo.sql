-- =====================================================
-- IMPORT-DASH - SCHEMA COMPLETO DE BASE DE DATOS
-- Generado: 2025-01-22
-- Para importar a Supabase Local
-- =====================================================

-- =====================================================
-- PASO 1: CREAR ENUM DE ROLES
-- =====================================================
DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'app_role') THEN
    CREATE TYPE public.app_role AS ENUM ('admin', 'user', 'supervisor', 'mechanic');
  END IF;
END $$;

-- =====================================================
-- PASO 2: CREAR TABLAS
-- =====================================================

-- Tabla: cat_codigos_pieza
CREATE TABLE IF NOT EXISTS public.cat_codigos_pieza (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  numero_parte TEXT NOT NULL UNIQUE,
  descripcion TEXT NOT NULL,
  tipo TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabla: cat_intervalos_mantenimiento
CREATE TABLE IF NOT EXISTS public.cat_intervalos_mantenimiento (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  codigo TEXT NOT NULL UNIQUE,
  nombre TEXT NOT NULL,
  horas_intervalo INTEGER NOT NULL,
  descripcion TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabla: cat_modelos
CREATE TABLE IF NOT EXISTS public.cat_modelos (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  modelo TEXT NOT NULL,
  categoria TEXT NOT NULL,
  serie_desde TEXT,
  serie_hasta TEXT,
  motor TEXT,
  capacidad_aceite_motor NUMERIC,
  capacidad_hidraulico NUMERIC,
  capacidad_refrigerante NUMERIC,
  notas TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabla: cat_modelo_intervalo_piezas
CREATE TABLE IF NOT EXISTS public.cat_modelo_intervalo_piezas (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  modelo_id BIGINT REFERENCES public.cat_modelos(id),
  intervalo_id BIGINT REFERENCES public.cat_intervalos_mantenimiento(id),
  pieza_id BIGINT REFERENCES public.cat_codigos_pieza(id),
  cantidad INTEGER DEFAULT 1,
  notas TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(modelo_id, intervalo_id, pieza_id)
);

-- Tabla: configuraciones_sistema
CREATE TABLE IF NOT EXISTS public.configuraciones_sistema (
  id INTEGER PRIMARY KEY DEFAULT 1,
  alerta_critica INTEGER NOT NULL DEFAULT 15,
  alerta_preventiva INTEGER NOT NULL DEFAULT 50,
  permitir_importaciones BOOLEAN NOT NULL DEFAULT true,
  notificar_email BOOLEAN NOT NULL DEFAULT true,
  notificar_whatsapp BOOLEAN NOT NULL DEFAULT false,
  notificar_dispositivo BOOLEAN NOT NULL DEFAULT true,
  modo_oscuro_automatico BOOLEAN NOT NULL DEFAULT true,
  correo_soporte TEXT,
  correo_notificaciones TEXT,
  telefono_whatsapp TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabla: equipos
CREATE TABLE IF NOT EXISTS public.equipos (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ficha TEXT NOT NULL,
  nombre TEXT NOT NULL,
  marca TEXT NOT NULL,
  modelo TEXT NOT NULL,
  numero_serie TEXT NOT NULL,
  placa TEXT NOT NULL,
  categoria TEXT NOT NULL,
  empresa TEXT NOT NULL DEFAULT 'ALITO EIRL',
  activo BOOLEAN NOT NULL DEFAULT true,
  motivo_inactividad TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabla: planes_mantenimiento
CREATE TABLE IF NOT EXISTS public.planes_mantenimiento (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre TEXT NOT NULL,
  marca TEXT NOT NULL,
  modelo TEXT,
  categoria TEXT NOT NULL,
  descripcion TEXT,
  activo BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabla: plan_intervalos
CREATE TABLE IF NOT EXISTS public.plan_intervalos (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  plan_id BIGINT NOT NULL REFERENCES public.planes_mantenimiento(id) ON DELETE CASCADE,
  codigo TEXT NOT NULL,
  nombre TEXT NOT NULL,
  horas_intervalo INTEGER NOT NULL,
  descripcion TEXT,
  tareas JSONB DEFAULT '[]'::jsonb,
  orden INTEGER NOT NULL DEFAULT 0,
  es_activo BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabla: kits_mantenimiento
CREATE TABLE IF NOT EXISTS public.kits_mantenimiento (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  codigo TEXT NOT NULL,
  nombre TEXT NOT NULL,
  descripcion TEXT,
  marca TEXT,
  modelo_aplicable TEXT,
  categoria TEXT,
  intervalo_horas INTEGER,
  activo BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabla: kit_piezas
CREATE TABLE IF NOT EXISTS public.kit_piezas (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  kit_id BIGINT NOT NULL REFERENCES public.kits_mantenimiento(id) ON DELETE CASCADE,
  numero_parte TEXT NOT NULL,
  descripcion TEXT NOT NULL,
  tipo TEXT NOT NULL,
  cantidad INTEGER NOT NULL DEFAULT 1,
  unidad TEXT DEFAULT 'unidad',
  notas TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabla: plan_intervalo_kits
CREATE TABLE IF NOT EXISTS public.plan_intervalo_kits (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  plan_intervalo_id BIGINT NOT NULL REFERENCES public.plan_intervalos(id) ON DELETE CASCADE,
  kit_id BIGINT NOT NULL REFERENCES public.kits_mantenimiento(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabla: equipo_planes
CREATE TABLE IF NOT EXISTS public.equipo_planes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  equipo_id BIGINT NOT NULL REFERENCES public.equipos(id) ON DELETE CASCADE,
  plan_id BIGINT NOT NULL REFERENCES public.planes_mantenimiento(id) ON DELETE CASCADE,
  fecha_inicio TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  horas_inicio NUMERIC NOT NULL DEFAULT 0,
  activo BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(equipo_id, plan_id)
);

-- Tabla: mantenimientos_programados
CREATE TABLE IF NOT EXISTS public.mantenimientos_programados (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ficha TEXT NOT NULL,
  nombre_equipo TEXT NOT NULL,
  tipo_mantenimiento TEXT NOT NULL,
  horas_km_actuales NUMERIC NOT NULL DEFAULT 0,
  fecha_ultima_actualizacion TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  frecuencia NUMERIC NOT NULL,
  fecha_ultimo_mantenimiento TIMESTAMPTZ,
  horas_km_ultimo_mantenimiento NUMERIC NOT NULL DEFAULT 0,
  proximo_mantenimiento NUMERIC NOT NULL,
  horas_km_restante NUMERIC NOT NULL,
  activo BOOLEAN NOT NULL DEFAULT true,
  plan_id BIGINT REFERENCES public.planes_mantenimiento(id),
  kit_usado_id BIGINT REFERENCES public.kits_mantenimiento(id),
  partes_consumidas JSONB DEFAULT '[]'::jsonb,
  intervalo_codigo TEXT,
  proximo_intervalo_codigo TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabla: inventarios
CREATE TABLE IF NOT EXISTS public.inventarios (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre TEXT NOT NULL,
  numero_parte TEXT NOT NULL DEFAULT '',
  tipo TEXT NOT NULL,
  sistema TEXT,
  categoria_equipo TEXT NOT NULL,
  cantidad INTEGER NOT NULL DEFAULT 0,
  stock_minimo INTEGER NOT NULL DEFAULT 5,
  movimientos JSONB DEFAULT '[]'::jsonb,
  activo BOOLEAN NOT NULL DEFAULT true,
  codigo_identificacion TEXT NOT NULL,
  ubicacion TEXT,
  empresa_suplidora TEXT NOT NULL,
  marca_fabricante TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabla: historial_eventos
CREATE TABLE IF NOT EXISTS public.historial_eventos (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tipo_evento TEXT NOT NULL,
  modulo TEXT NOT NULL,
  ficha_equipo TEXT,
  nombre_equipo TEXT,
  descripcion TEXT NOT NULL,
  usuario_responsable TEXT NOT NULL DEFAULT 'Sistema',
  nivel_importancia TEXT NOT NULL DEFAULT 'info',
  datos_antes JSONB,
  datos_despues JSONB,
  metadata JSONB,
  kit_usado_id BIGINT REFERENCES public.kits_mantenimiento(id),
  partes_consumidas JSONB DEFAULT '[]'::jsonb,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Tabla: notificaciones
CREATE TABLE IF NOT EXISTS public.notificaciones (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tipo TEXT NOT NULL,
  titulo TEXT NOT NULL,
  mensaje TEXT NOT NULL,
  ficha_equipo TEXT,
  nombre_equipo TEXT,
  nivel TEXT NOT NULL DEFAULT 'info',
  accion_url TEXT,
  leida BOOLEAN NOT NULL DEFAULT false,
  metadata JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Tabla: notificaciones_salientes
CREATE TABLE IF NOT EXISTS public.notificaciones_salientes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  notificacion_id BIGINT REFERENCES public.notificaciones(id),
  canal TEXT NOT NULL,
  destinatario TEXT NOT NULL,
  contenido TEXT NOT NULL,
  enviado_en TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabla: overrides_planes
CREATE TABLE IF NOT EXISTS public.overrides_planes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ficha_equipo TEXT NOT NULL,
  plan_original_id BIGINT REFERENCES public.planes_mantenimiento(id),
  plan_forzado_id BIGINT NOT NULL REFERENCES public.planes_mantenimiento(id),
  motivo TEXT NOT NULL DEFAULT '',
  usuario_email TEXT NOT NULL DEFAULT 'sistema@local',
  activo BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Tabla: user_roles
CREATE TABLE IF NOT EXISTS public.user_roles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL,
  role public.app_role NOT NULL DEFAULT 'user',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Tabla: maintenance_submissions
CREATE TABLE IF NOT EXISTS public.maintenance_submissions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  equipo_id INTEGER NOT NULL REFERENCES public.equipos(id),
  horas_km_actuales INTEGER NOT NULL,
  fecha_mantenimiento TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  tipo_mantenimiento TEXT,
  descripcion_trabajo TEXT,
  observaciones TEXT,
  partes_usadas JSONB DEFAULT '[]'::jsonb,
  status TEXT NOT NULL DEFAULT 'pending',
  created_by UUID NOT NULL,
  reviewed_by UUID,
  reviewed_at TIMESTAMPTZ,
  admin_feedback TEXT,
  linked_maintenance_id INTEGER REFERENCES public.mantenimientos_programados(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabla: submission_attachments
CREATE TABLE IF NOT EXISTS public.submission_attachments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  submission_id UUID NOT NULL REFERENCES public.maintenance_submissions(id) ON DELETE CASCADE,
  storage_path TEXT NOT NULL,
  filename TEXT NOT NULL,
  mime_type TEXT,
  file_size INTEGER,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabla: equipment_tickets
CREATE TABLE IF NOT EXISTS public.equipment_tickets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  equipo_id INTEGER NOT NULL REFERENCES public.equipos(id),
  ficha VARCHAR(50) NOT NULL,
  titulo VARCHAR(255) NOT NULL,
  descripcion TEXT NOT NULL,
  tipo_problema VARCHAR(50) NOT NULL,
  prioridad VARCHAR(20) DEFAULT 'media',
  pieza_solicitada VARCHAR(255),
  numero_parte VARCHAR(100),
  cantidad_requerida INTEGER DEFAULT 1,
  status VARCHAR(50) DEFAULT 'abierto',
  cotizacion_monto NUMERIC(12,2),
  cotizacion_proveedor VARCHAR(255),
  cotizacion_fecha DATE,
  orden_compra_numero VARCHAR(100),
  orden_compra_fecha DATE,
  fecha_recepcion_pieza DATE,
  fecha_inicio_reparacion DATE,
  fecha_cierre DATE,
  created_by VARCHAR(255) NOT NULL,
  assigned_to VARCHAR(255),
  resolucion TEXT,
  notas_admin TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabla: ticket_attachments
CREATE TABLE IF NOT EXISTS public.ticket_attachments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  ticket_id UUID NOT NULL REFERENCES public.equipment_tickets(id) ON DELETE CASCADE,
  file_name VARCHAR(255) NOT NULL,
  file_type VARCHAR(50) NOT NULL,
  file_path VARCHAR(500) NOT NULL,
  file_size INTEGER,
  mime_type VARCHAR(100),
  uploaded_by VARCHAR(255) NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabla: ticket_history
CREATE TABLE IF NOT EXISTS public.ticket_history (
  id SERIAL PRIMARY KEY,
  ticket_id UUID NOT NULL REFERENCES public.equipment_tickets(id) ON DELETE CASCADE,
  action VARCHAR(100) NOT NULL,
  status_from VARCHAR(50),
  status_to VARCHAR(50),
  comment TEXT,
  performed_by VARCHAR(255) NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- =====================================================
-- PASO 3: CREAR VISTA
-- =====================================================

CREATE OR REPLACE VIEW public.equipos_con_overrides AS
SELECT 
  o.ficha_equipo,
  o.motivo,
  o.created_at as override_fecha,
  o.plan_forzado_id,
  pf.nombre as plan_forzado_nombre,
  o.plan_original_id,
  po.nombre as plan_original_nombre,
  pf.marca as plan_marca,
  pf.modelo as plan_modelo,
  o.usuario_email
FROM public.overrides_planes o
LEFT JOIN public.planes_mantenimiento pf ON o.plan_forzado_id = pf.id
LEFT JOIN public.planes_mantenimiento po ON o.plan_original_id = po.id
WHERE o.activo = true;

-- =====================================================
-- PASO 4: CREAR ÍNDICES
-- =====================================================

CREATE INDEX IF NOT EXISTS idx_cat_codigos_tipo ON public.cat_codigos_pieza(tipo);
CREATE INDEX IF NOT EXISTS idx_cat_modelos_categoria ON public.cat_modelos(categoria);
CREATE INDEX IF NOT EXISTS idx_cat_modelos_modelo ON public.cat_modelos(modelo);
CREATE INDEX IF NOT EXISTS idx_cat_mip_modelo ON public.cat_modelo_intervalo_piezas(modelo_id);
CREATE INDEX IF NOT EXISTS idx_cat_mip_intervalo ON public.cat_modelo_intervalo_piezas(intervalo_id);
CREATE INDEX IF NOT EXISTS idx_equipos_empresa ON public.equipos(empresa);
CREATE INDEX IF NOT EXISTS idx_equipo_planes_equipo ON public.equipo_planes(equipo_id) WHERE activo = true;
CREATE INDEX IF NOT EXISTS idx_historial_ficha ON public.historial_eventos(ficha_equipo);
CREATE INDEX IF NOT EXISTS idx_historial_modulo ON public.historial_eventos(modulo);
CREATE INDEX IF NOT EXISTS idx_historial_nivel ON public.historial_eventos(nivel_importancia);
CREATE INDEX IF NOT EXISTS idx_historial_created_at ON public.historial_eventos(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_inventarios_codigo ON public.inventarios(codigo_identificacion);
CREATE INDEX IF NOT EXISTS idx_inventarios_tipo ON public.inventarios(tipo);
CREATE INDEX IF NOT EXISTS idx_kits_modelo ON public.kits_mantenimiento(modelo_aplicable);
CREATE INDEX IF NOT EXISTS idx_kits_marca ON public.kits_mantenimiento(marca);
CREATE INDEX IF NOT EXISTS idx_mantenimientos_ficha ON public.mantenimientos_programados(ficha);
CREATE INDEX IF NOT EXISTS idx_notificaciones_tipo ON public.notificaciones(tipo);
CREATE INDEX IF NOT EXISTS idx_notificaciones_ficha ON public.notificaciones(ficha_equipo);
CREATE INDEX IF NOT EXISTS idx_notificaciones_leida ON public.notificaciones(leida);
CREATE INDEX IF NOT EXISTS idx_plan_intervalos_plan ON public.plan_intervalos(plan_id);
CREATE INDEX IF NOT EXISTS idx_planes_marca ON public.planes_mantenimiento(marca);
CREATE INDEX IF NOT EXISTS idx_planes_modelo ON public.planes_mantenimiento(modelo);
CREATE INDEX IF NOT EXISTS idx_submissions_equipo ON public.maintenance_submissions(equipo_id);
CREATE INDEX IF NOT EXISTS idx_submissions_status ON public.maintenance_submissions(status);
CREATE INDEX IF NOT EXISTS idx_tickets_equipo ON public.equipment_tickets(equipo_id);
CREATE INDEX IF NOT EXISTS idx_tickets_status ON public.equipment_tickets(status);
CREATE INDEX IF NOT EXISTS idx_tickets_ficha ON public.equipment_tickets(ficha);
CREATE INDEX IF NOT EXISTS idx_tickets_created ON public.equipment_tickets(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_tickets_priority ON public.equipment_tickets(prioridad);
CREATE INDEX IF NOT EXISTS idx_ticket_attachments_ticket ON public.ticket_attachments(ticket_id);
CREATE INDEX IF NOT EXISTS idx_ticket_history_ticket ON public.ticket_history(ticket_id);

-- =====================================================
-- PASO 5: CREAR FUNCIONES
-- =====================================================

-- Función: has_role
CREATE OR REPLACE FUNCTION public.has_role(_user_id uuid, _role app_role)
RETURNS boolean
LANGUAGE sql
STABLE SECURITY DEFINER
SET search_path TO 'public'
AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.user_roles
    WHERE user_id = _user_id
      AND role = _role
  )
$$;

-- Función: get_users_with_emails
CREATE OR REPLACE FUNCTION public.get_users_with_emails()
RETURNS TABLE(id uuid, email text, created_at timestamp with time zone, last_sign_in_at timestamp with time zone)
LANGUAGE sql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
  SELECT au.id, au.email, au.created_at, au.last_sign_in_at
  FROM auth.users au ORDER BY au.created_at DESC;
$$;

-- Función: calcular_proximo_mantenimiento
CREATE OR REPLACE FUNCTION public.calcular_proximo_mantenimiento(p_horas_actuales numeric, p_plan_id bigint)
RETURNS TABLE(intervalo_id bigint, intervalo_codigo text, intervalo_nombre text, horas_intervalo integer, horas_proximo numeric, kit_id bigint)
LANGUAGE plpgsql
STABLE
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    pi.id,
    pi.codigo,
    pi.nombre,
    pi.horas_intervalo,
    CEIL(p_horas_actuales / pi.horas_intervalo) * pi.horas_intervalo AS horas_proximo,
    pik.kit_id
  FROM public.plan_intervalos pi
  LEFT JOIN public.plan_intervalo_kits pik ON pik.plan_intervalo_id = pi.id
  WHERE pi.plan_id = p_plan_id
    AND pi.es_activo = true
  ORDER BY pi.orden ASC, pi.horas_intervalo ASC
  LIMIT 1;
END;
$$;

-- Función: generar_notificaciones_mantenimientos
CREATE OR REPLACE FUNCTION public.generar_notificaciones_mantenimientos()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
BEGIN
  INSERT INTO public.notificaciones (tipo, titulo, mensaje, ficha_equipo, nombre_equipo, nivel, accion_url, metadata)
  SELECT 
    'mantenimiento_vencido',
    'Mantenimiento Vencido: ' || nombre_equipo,
    'El equipo ' || nombre_equipo || ' tiene un mantenimiento vencido por ' || ABS(horas_km_restante) || ' unidades.',
    ficha,
    nombre_equipo,
    'critical',
    '/mantenimiento?ficha=' || ficha,
    jsonb_build_object('horas_km_restante', horas_km_restante, 'proximo_mantenimiento', proximo_mantenimiento)
  FROM public.mantenimientos_programados
  WHERE activo = true 
    AND horas_km_restante < 0
    AND NOT EXISTS (
      SELECT 1 FROM public.notificaciones n
      WHERE n.tipo = 'mantenimiento_vencido'
        AND n.ficha_equipo = mantenimientos_programados.ficha
        AND n.leida = false
    );
  
  INSERT INTO public.notificaciones (tipo, titulo, mensaje, ficha_equipo, nombre_equipo, nivel, accion_url, metadata)
  SELECT 
    'mantenimiento_proximo',
    'Mantenimiento Próximo: ' || nombre_equipo,
    'El equipo ' || nombre_equipo || ' necesitará mantenimiento en ' || horas_km_restante || ' unidades.',
    ficha,
    nombre_equipo,
    'warning',
    '/mantenimiento?ficha=' || ficha,
    jsonb_build_object('horas_km_restante', horas_km_restante, 'proximo_mantenimiento', proximo_mantenimiento)
  FROM public.mantenimientos_programados
  WHERE activo = true 
    AND horas_km_restante > 0 
    AND horas_km_restante <= 50
    AND NOT EXISTS (
      SELECT 1 FROM public.notificaciones n
      WHERE n.tipo = 'mantenimiento_proximo'
        AND n.ficha_equipo = mantenimientos_programados.ficha
        AND n.leida = false
    );
END;
$$;

-- Función: generar_notificaciones_stock_bajo
CREATE OR REPLACE FUNCTION public.generar_notificaciones_stock_bajo()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
BEGIN
  INSERT INTO public.notificaciones (tipo, titulo, mensaje, nivel, accion_url, metadata)
  SELECT 
    'stock_bajo',
    'Stock Bajo: ' || nombre,
    'El inventario ' || nombre || ' tiene solo ' || cantidad || ' unidades disponibles.',
    CASE 
      WHEN cantidad = 0 THEN 'critical'
      WHEN cantidad <= 3 THEN 'warning'
      ELSE 'info'
    END,
    '/inventario',
    jsonb_build_object('id_inventario', id, 'cantidad', cantidad, 'codigo', codigo_identificacion)
  FROM public.inventarios
  WHERE activo = true 
    AND cantidad <= 5
    AND NOT EXISTS (
      SELECT 1 FROM public.notificaciones n
      WHERE n.tipo = 'stock_bajo'
        AND (n.metadata->>'id_inventario')::bigint = inventarios.id
        AND n.leida = false
    );
END;
$$;

-- Función: update_overrides_planes_updated_at
CREATE OR REPLACE FUNCTION public.update_overrides_planes_updated_at()
RETURNS trigger
LANGUAGE plpgsql
SET search_path TO 'public'
AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

-- Función: update_equipment_tickets_updated_at
CREATE OR REPLACE FUNCTION public.update_equipment_tickets_updated_at()
RETURNS trigger
LANGUAGE plpgsql
SET search_path TO 'public'
AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- Función: update_submissions_updated_at
CREATE OR REPLACE FUNCTION public.update_submissions_updated_at()
RETURNS trigger
LANGUAGE plpgsql
SET search_path TO 'public'
AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- Función: handle_new_user_role
CREATE OR REPLACE FUNCTION public.handle_new_user_role()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
BEGIN
  INSERT INTO public.user_roles (user_id, role)
  VALUES (NEW.id, 'user');
  RETURN NEW;
END;
$$;

-- Función: notify_admins_new_submission
CREATE OR REPLACE FUNCTION public.notify_admins_new_submission()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
DECLARE
  v_equipo RECORD;
BEGIN
  SELECT * INTO v_equipo FROM equipos WHERE id = NEW.equipo_id;
  INSERT INTO notificaciones (tipo, nivel, titulo, mensaje, ficha_equipo, nombre_equipo, metadata)
  VALUES (
    'new_submission',
    'info',
    'Nuevo Reporte de Mecánico',
    'Se ha recibido un nuevo reporte de mantenimiento para revisión.',
    v_equipo.ficha,
    v_equipo.nombre,
    jsonb_build_object('submission_id', NEW.id, 'equipo_id', NEW.equipo_id)
  );
  RETURN NEW;
END;
$$;

-- Función: approve_and_integrate_submission
CREATE OR REPLACE FUNCTION public.approve_and_integrate_submission(p_submission_id uuid, p_admin_feedback text DEFAULT NULL::text)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
DECLARE
  v_submission RECORD;
  v_historial_id INTEGER;
  v_equipo_ficha TEXT;
  v_partes_usadas JSONB;
  v_frecuencia NUMERIC;
  v_nuevo_proximo NUMERIC;
BEGIN
  IF NOT has_role(auth.uid(), 'admin') THEN
    RETURN json_build_object('success', false, 'error', 'No autorizado');
  END IF;

  SELECT * INTO v_submission FROM maintenance_submissions WHERE id = p_submission_id AND status = 'pending';
  IF NOT FOUND THEN
    RETURN json_build_object('success', false, 'error', 'Submission no encontrado o ya procesado');
  END IF;

  SELECT ficha INTO v_equipo_ficha FROM equipos WHERE id = v_submission.equipo_id;
  SELECT frecuencia INTO v_frecuencia FROM mantenimientos_programados WHERE ficha = v_equipo_ficha AND activo = true LIMIT 1;
  v_nuevo_proximo := v_submission.horas_km_actuales + COALESCE(v_frecuencia, 250);

  IF v_submission.partes_usadas IS NULL THEN
    v_partes_usadas := '[]'::jsonb;
  ELSIF jsonb_typeof(v_submission.partes_usadas) = 'array' THEN
    v_partes_usadas := v_submission.partes_usadas;
  ELSE
    v_partes_usadas := '[]'::jsonb;
  END IF;

  INSERT INTO historial_eventos (
    tipo_evento, modulo, ficha_equipo, descripcion, metadata, usuario_responsable, partes_consumidas
  ) VALUES (
    'mantenimiento_realizado',
    'mantenimientos',
    v_equipo_ficha,
    COALESCE(v_submission.descripcion_trabajo, 'Mantenimiento realizado por mecánico'),
    jsonb_build_object(
      'submission_id', p_submission_id,
      'horas_km_actuales', v_submission.horas_km_actuales,
      'tipo_mantenimiento', v_submission.tipo_mantenimiento,
      'partes_usadas', v_partes_usadas,
      'observaciones', v_submission.observaciones,
      'fecha_mantenimiento', v_submission.fecha_mantenimiento,
      'proximo_mantenimiento', v_nuevo_proximo
    ),
    (SELECT email FROM auth.users WHERE id = v_submission.created_by),
    v_partes_usadas
  ) RETURNING id INTO v_historial_id;

  UPDATE mantenimientos_programados
  SET 
    horas_km_actuales = v_submission.horas_km_actuales,
    horas_km_ultimo_mantenimiento = v_submission.horas_km_actuales,
    fecha_ultimo_mantenimiento = v_submission.fecha_mantenimiento,
    fecha_ultima_actualizacion = NOW(),
    proximo_mantenimiento = v_nuevo_proximo,
    horas_km_restante = v_nuevo_proximo - v_submission.horas_km_actuales,
    partes_consumidas = v_partes_usadas
  WHERE ficha = v_equipo_ficha AND activo = true;

  UPDATE maintenance_submissions
  SET 
    status = 'approved', 
    reviewed_by = auth.uid(), 
    reviewed_at = NOW(),
    admin_feedback = COALESCE(p_admin_feedback, 'Aprobado e integrado al sistema')
  WHERE id = p_submission_id;

  INSERT INTO notificaciones (tipo, titulo, mensaje, nivel, ficha_equipo, metadata)
  VALUES (
    'submission_approved',
    'Reporte Aprobado',
    'Tu reporte de mantenimiento para ' || v_equipo_ficha || ' ha sido aprobado. Próximo servicio: ' || v_nuevo_proximo || ' hrs.',
    'info',
    v_equipo_ficha,
    jsonb_build_object('submission_id', p_submission_id, 'historial_id', v_historial_id, 'proximo_mantenimiento', v_nuevo_proximo)
  );

  RETURN json_build_object(
    'success', true, 
    'historial_id', v_historial_id, 
    'message', 'Mantenimiento registrado. Próximo servicio: ' || v_nuevo_proximo || ' hrs',
    'equipo_ficha', v_equipo_ficha,
    'proximo_mantenimiento', v_nuevo_proximo
  );
END;
$$;

-- Función: reject_submission
CREATE OR REPLACE FUNCTION public.reject_submission(p_submission_id uuid, p_feedback text)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
BEGIN
  IF NOT has_role(auth.uid(), 'admin') THEN
    RETURN json_build_object('success', false, 'error', 'No autorizado');
  END IF;

  IF NOT EXISTS (SELECT 1 FROM maintenance_submissions WHERE id = p_submission_id AND status = 'pending') THEN
    RETURN json_build_object('success', false, 'error', 'Submission no encontrado o ya procesado');
  END IF;

  UPDATE maintenance_submissions
  SET status = 'rejected', reviewed_by = auth.uid(), reviewed_at = NOW(), admin_feedback = p_feedback
  WHERE id = p_submission_id;

  RETURN json_build_object('success', true, 'message', 'Submission rechazado');
END;
$$;

-- Función: actualizar_inventario_post_mantenimiento
CREATE OR REPLACE FUNCTION public.actualizar_inventario_post_mantenimiento()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
DECLARE
  v_parte jsonb;
  v_inventario_id bigint;
BEGIN
  IF NEW.partes_consumidas IS NOT NULL AND jsonb_array_length(NEW.partes_consumidas) > 0 THEN
    FOR v_parte IN SELECT * FROM jsonb_array_elements(NEW.partes_consumidas)
    LOOP
      SELECT id INTO v_inventario_id
      FROM public.inventarios
      WHERE numero_parte = (v_parte->>'numero_parte')::text
      LIMIT 1;
      
      IF v_inventario_id IS NOT NULL THEN
        UPDATE public.inventarios
        SET cantidad = GREATEST(0, cantidad - (v_parte->>'cantidad')::integer)
        WHERE id = v_inventario_id;
        
        PERFORM 1
        FROM public.inventarios
        WHERE id = v_inventario_id
          AND cantidad <= stock_minimo;
        
        IF FOUND THEN
          INSERT INTO public.notificaciones (tipo, titulo, mensaje, nivel, metadata)
          SELECT
            'stock_bajo',
            'Stock Bajo: ' || nombre,
            'El inventario ' || nombre || ' (P/N: ' || numero_parte || ') tiene solo ' || cantidad || ' unidades.',
            CASE
              WHEN cantidad = 0 THEN 'critical'
              WHEN cantidad <= 3 THEN 'warning'
              ELSE 'info'
            END,
            jsonb_build_object('inventario_id', id, 'numero_parte', numero_parte, 'cantidad', cantidad)
          FROM public.inventarios
          WHERE id = v_inventario_id
          ON CONFLICT DO NOTHING;
        END IF;
      END IF;
    END LOOP;
  END IF;
  RETURN NEW;
END;
$$;

-- =====================================================
-- PASO 6: CREAR TRIGGERS
-- =====================================================

-- Trigger: auto-assign user role on signup
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_user_role();

-- Trigger: update overrides_planes updated_at
DROP TRIGGER IF EXISTS trigger_update_overrides_planes ON public.overrides_planes;
CREATE TRIGGER trigger_update_overrides_planes
  BEFORE UPDATE ON public.overrides_planes
  FOR EACH ROW
  EXECUTE FUNCTION public.update_overrides_planes_updated_at();

-- Trigger: update equipment_tickets updated_at
DROP TRIGGER IF EXISTS trigger_equipment_tickets_updated_at ON public.equipment_tickets;
CREATE TRIGGER trigger_equipment_tickets_updated_at
  BEFORE UPDATE ON public.equipment_tickets
  FOR EACH ROW
  EXECUTE FUNCTION public.update_equipment_tickets_updated_at();

-- Trigger: update maintenance_submissions updated_at
DROP TRIGGER IF EXISTS trigger_submissions_updated_at ON public.maintenance_submissions;
CREATE TRIGGER trigger_submissions_updated_at
  BEFORE UPDATE ON public.maintenance_submissions
  FOR EACH ROW
  EXECUTE FUNCTION public.update_submissions_updated_at();

-- Trigger: notify admins on new submission
DROP TRIGGER IF EXISTS trigger_notify_new_submission ON public.maintenance_submissions;
CREATE TRIGGER trigger_notify_new_submission
  AFTER INSERT ON public.maintenance_submissions
  FOR EACH ROW
  EXECUTE FUNCTION public.notify_admins_new_submission();

-- Trigger: actualizar inventario post mantenimiento
DROP TRIGGER IF EXISTS trigger_actualizar_inventario ON public.historial_eventos;
CREATE TRIGGER trigger_actualizar_inventario
  AFTER INSERT ON public.historial_eventos
  FOR EACH ROW
  WHEN (NEW.tipo_evento = 'mantenimiento_realizado')
  EXECUTE FUNCTION public.actualizar_inventario_post_mantenimiento();

-- =====================================================
-- PASO 7: HABILITAR RLS EN TODAS LAS TABLAS
-- =====================================================

ALTER TABLE public.cat_codigos_pieza ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.cat_intervalos_mantenimiento ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.cat_modelo_intervalo_piezas ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.cat_modelos ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.configuraciones_sistema ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.equipos ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.equipo_planes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.equipment_tickets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.historial_eventos ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.inventarios ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.kits_mantenimiento ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.kit_piezas ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.maintenance_submissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.mantenimientos_programados ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notificaciones ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notificaciones_salientes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.overrides_planes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.planes_mantenimiento ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.plan_intervalos ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.plan_intervalo_kits ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.submission_attachments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ticket_attachments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ticket_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;

-- =====================================================
-- PASO 8: POLÍTICAS RLS
-- =====================================================

-- cat_codigos_pieza
CREATE POLICY "Allow public read access to cat_codigos_pieza" ON public.cat_codigos_pieza FOR SELECT USING (true);

-- cat_intervalos_mantenimiento
CREATE POLICY "Allow public read access to cat_intervalos_mantenimiento" ON public.cat_intervalos_mantenimiento FOR SELECT USING (true);

-- cat_modelo_intervalo_piezas
CREATE POLICY "Allow public read access to cat_modelo_intervalo_piezas" ON public.cat_modelo_intervalo_piezas FOR SELECT USING (true);
CREATE POLICY "Allow public insert to cat_modelo_intervalo_piezas" ON public.cat_modelo_intervalo_piezas FOR INSERT WITH CHECK (true);
CREATE POLICY "Allow public update to cat_modelo_intervalo_piezas" ON public.cat_modelo_intervalo_piezas FOR UPDATE USING (true);

-- cat_modelos
CREATE POLICY "Allow public read access to cat_modelos" ON public.cat_modelos FOR SELECT USING (true);
CREATE POLICY "Allow public insert to cat_modelos" ON public.cat_modelos FOR INSERT WITH CHECK (true);
CREATE POLICY "Allow public update to cat_modelos" ON public.cat_modelos FOR UPDATE USING (true);

-- configuraciones_sistema
CREATE POLICY "Allow public read access to system configuration" ON public.configuraciones_sistema FOR SELECT USING (true);
CREATE POLICY "Allow public insert access to system configuration" ON public.configuraciones_sistema FOR INSERT WITH CHECK (true);
CREATE POLICY "Allow public update access to system configuration" ON public.configuraciones_sistema FOR UPDATE USING (true);

-- equipos
CREATE POLICY "Permitir lectura pública de equipos" ON public.equipos FOR SELECT USING (true);
CREATE POLICY "Permitir inserción pública de equipos" ON public.equipos FOR INSERT WITH CHECK (true);
CREATE POLICY "Permitir actualización pública de equipos" ON public.equipos FOR UPDATE USING (true);
CREATE POLICY "Permitir eliminación pública de equipos" ON public.equipos FOR DELETE USING (true);

-- equipo_planes
CREATE POLICY "Permitir lectura pública de equipo_planes" ON public.equipo_planes FOR SELECT USING (true);
CREATE POLICY "Permitir inserción pública de equipo_planes" ON public.equipo_planes FOR INSERT WITH CHECK (true);
CREATE POLICY "Permitir actualización pública de equipo_planes" ON public.equipo_planes FOR UPDATE USING (true);
CREATE POLICY "Permitir eliminación pública de equipo_planes" ON public.equipo_planes FOR DELETE USING (true);

-- equipment_tickets
CREATE POLICY "Authenticated users can view tickets" ON public.equipment_tickets FOR SELECT USING (auth.uid() IS NOT NULL);
CREATE POLICY "Authenticated users can create tickets" ON public.equipment_tickets FOR INSERT WITH CHECK (auth.uid() IS NOT NULL);
CREATE POLICY "Users can update tickets" ON public.equipment_tickets FOR UPDATE USING (
  auth.uid() IS NOT NULL AND (
    has_role(auth.uid(), 'admin') OR 
    has_role(auth.uid(), 'supervisor') OR 
    created_by = (SELECT email FROM auth.users WHERE id = auth.uid())
  )
);
CREATE POLICY "Admins can delete tickets" ON public.equipment_tickets FOR DELETE USING (has_role(auth.uid(), 'admin'));

-- historial_eventos
CREATE POLICY "Permitir lectura pública de historial" ON public.historial_eventos FOR SELECT USING (true);
CREATE POLICY "Permitir inserción pública de historial" ON public.historial_eventos FOR INSERT WITH CHECK (true);
CREATE POLICY "Permitir eliminación pública de historial" ON public.historial_eventos FOR DELETE USING (true);

-- inventarios
CREATE POLICY "Permitir lectura pública de inventarios" ON public.inventarios FOR SELECT USING (true);
CREATE POLICY "Permitir inserción pública de inventarios" ON public.inventarios FOR INSERT WITH CHECK (true);
CREATE POLICY "Permitir actualización pública de inventarios" ON public.inventarios FOR UPDATE USING (true);
CREATE POLICY "Permitir eliminación pública de inventarios" ON public.inventarios FOR DELETE USING (true);

-- kits_mantenimiento
CREATE POLICY "Permitir lectura pública de kits" ON public.kits_mantenimiento FOR SELECT USING (true);
CREATE POLICY "Permitir inserción pública de kits" ON public.kits_mantenimiento FOR INSERT WITH CHECK (true);
CREATE POLICY "Permitir actualización pública de kits" ON public.kits_mantenimiento FOR UPDATE USING (true);
CREATE POLICY "Permitir eliminación pública de kits" ON public.kits_mantenimiento FOR DELETE USING (true);

-- kit_piezas
CREATE POLICY "Permitir lectura pública de piezas kit" ON public.kit_piezas FOR SELECT USING (true);
CREATE POLICY "Permitir inserción pública de piezas kit" ON public.kit_piezas FOR INSERT WITH CHECK (true);
CREATE POLICY "Permitir actualización pública de piezas kit" ON public.kit_piezas FOR UPDATE USING (true);
CREATE POLICY "Permitir eliminación pública de piezas kit" ON public.kit_piezas FOR DELETE USING (true);

-- maintenance_submissions
CREATE POLICY "Users can view submissions" ON public.maintenance_submissions FOR SELECT USING (
  auth.uid() = created_by OR has_role(auth.uid(), 'admin') OR has_role(auth.uid(), 'supervisor')
);
CREATE POLICY "Mechanics can insert own submissions" ON public.maintenance_submissions FOR INSERT WITH CHECK (auth.uid() = created_by);
CREATE POLICY "Admins can update submissions" ON public.maintenance_submissions FOR UPDATE USING (has_role(auth.uid(), 'admin'));

-- mantenimientos_programados
CREATE POLICY "Permitir lectura pública de mantenimientos" ON public.mantenimientos_programados FOR SELECT USING (true);
CREATE POLICY "Permitir inserción pública de mantenimientos" ON public.mantenimientos_programados FOR INSERT WITH CHECK (true);
CREATE POLICY "Permitir actualización pública de mantenimientos" ON public.mantenimientos_programados FOR UPDATE USING (true);
CREATE POLICY "Permitir eliminación pública de mantenimientos" ON public.mantenimientos_programados FOR DELETE USING (true);

-- notificaciones
CREATE POLICY "Permitir lectura pública de notificaciones" ON public.notificaciones FOR SELECT USING (true);
CREATE POLICY "Permitir inserción pública de notificaciones" ON public.notificaciones FOR INSERT WITH CHECK (true);
CREATE POLICY "Permitir actualización pública de notificaciones" ON public.notificaciones FOR UPDATE USING (true);
CREATE POLICY "Permitir eliminación pública de notificaciones" ON public.notificaciones FOR DELETE USING (true);

-- notificaciones_salientes
CREATE POLICY "Allow public read access to notificaciones_salientes" ON public.notificaciones_salientes FOR SELECT USING (true);
CREATE POLICY "Allow public insert to notificaciones_salientes" ON public.notificaciones_salientes FOR INSERT WITH CHECK (true);

-- overrides_planes
CREATE POLICY "Permitir lectura pública de overrides_planes" ON public.overrides_planes FOR SELECT USING (true);
CREATE POLICY "Permitir inserción pública de overrides_planes" ON public.overrides_planes FOR INSERT WITH CHECK (true);
CREATE POLICY "Permitir actualización pública de overrides_planes" ON public.overrides_planes FOR UPDATE USING (true);
CREATE POLICY "Permitir eliminación pública de overrides_planes" ON public.overrides_planes FOR DELETE USING (true);

-- planes_mantenimiento
CREATE POLICY "Permitir lectura pública de planes" ON public.planes_mantenimiento FOR SELECT USING (true);
CREATE POLICY "Permitir inserción pública de planes" ON public.planes_mantenimiento FOR INSERT WITH CHECK (true);
CREATE POLICY "Permitir actualización pública de planes" ON public.planes_mantenimiento FOR UPDATE USING (true);
CREATE POLICY "Permitir eliminación pública de planes" ON public.planes_mantenimiento FOR DELETE USING (true);

-- plan_intervalos
CREATE POLICY "Permitir lectura pública de intervalos" ON public.plan_intervalos FOR SELECT USING (true);
CREATE POLICY "Permitir inserción pública de intervalos" ON public.plan_intervalos FOR INSERT WITH CHECK (true);
CREATE POLICY "Permitir actualización pública de intervalos" ON public.plan_intervalos FOR UPDATE USING (true);
CREATE POLICY "Permitir eliminación pública de intervalos" ON public.plan_intervalos FOR DELETE USING (true);

-- plan_intervalo_kits
CREATE POLICY "Permitir lectura pública de plan_intervalo_kits" ON public.plan_intervalo_kits FOR SELECT USING (true);
CREATE POLICY "Permitir inserción pública de plan_intervalo_kits" ON public.plan_intervalo_kits FOR INSERT WITH CHECK (true);
CREATE POLICY "Permitir actualización pública de plan_intervalo_kits" ON public.plan_intervalo_kits FOR UPDATE USING (true);
CREATE POLICY "Permitir eliminación pública de plan_intervalo_kits" ON public.plan_intervalo_kits FOR DELETE USING (true);

-- submission_attachments
CREATE POLICY "Users can view attachments" ON public.submission_attachments FOR SELECT USING (
  EXISTS (SELECT 1 FROM maintenance_submissions ms WHERE ms.id = submission_id AND ms.created_by = auth.uid()) OR 
  has_role(auth.uid(), 'admin') OR has_role(auth.uid(), 'supervisor')
);
CREATE POLICY "Users can insert own attachments" ON public.submission_attachments FOR INSERT WITH CHECK (
  EXISTS (SELECT 1 FROM maintenance_submissions ms WHERE ms.id = submission_id AND ms.created_by = auth.uid())
);

-- ticket_attachments
CREATE POLICY "Authenticated users can view attachments" ON public.ticket_attachments FOR SELECT USING (auth.uid() IS NOT NULL);
CREATE POLICY "Authenticated users can add attachments" ON public.ticket_attachments FOR INSERT WITH CHECK (auth.uid() IS NOT NULL);
CREATE POLICY "Admins can delete attachments" ON public.ticket_attachments FOR DELETE USING (has_role(auth.uid(), 'admin'));

-- ticket_history
CREATE POLICY "Authenticated users can view history" ON public.ticket_history FOR SELECT USING (auth.uid() IS NOT NULL);
CREATE POLICY "Authenticated users can add history" ON public.ticket_history FOR INSERT WITH CHECK (auth.uid() IS NOT NULL);

-- user_roles
CREATE POLICY "Users can view their own roles" ON public.user_roles FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Only authenticated users can view roles" ON public.user_roles FOR SELECT USING (true);
CREATE POLICY "Admins can view all user roles" ON public.user_roles FOR SELECT USING (has_role(auth.uid(), 'admin'));
CREATE POLICY "Admins can insert user roles" ON public.user_roles FOR INSERT WITH CHECK (has_role(auth.uid(), 'admin'));
CREATE POLICY "Admins can update user roles" ON public.user_roles FOR UPDATE USING (has_role(auth.uid(), 'admin'));
CREATE POLICY "Admins can delete user roles" ON public.user_roles FOR DELETE USING (has_role(auth.uid(), 'admin'));

-- =====================================================
-- PASO 9: CREAR STORAGE BUCKETS
-- =====================================================

INSERT INTO storage.buckets (id, name, public) VALUES ('submissions', 'submissions', false) ON CONFLICT DO NOTHING;
INSERT INTO storage.buckets (id, name, public) VALUES ('ticket-attachments', 'ticket-attachments', false) ON CONFLICT DO NOTHING;

-- Storage Policies para submissions
CREATE POLICY "Authenticated users can upload submissions" ON storage.objects FOR INSERT WITH CHECK (
  bucket_id = 'submissions' AND auth.uid() IS NOT NULL
);
CREATE POLICY "Users can view own submissions" ON storage.objects FOR SELECT USING (
  bucket_id = 'submissions' AND (auth.uid()::text = (storage.foldername(name))[1] OR has_role(auth.uid(), 'admin'))
);

-- Storage Policies para ticket-attachments
CREATE POLICY "Authenticated users can upload ticket attachments" ON storage.objects FOR INSERT WITH CHECK (
  bucket_id = 'ticket-attachments' AND auth.uid() IS NOT NULL
);
CREATE POLICY "Authenticated users can view ticket attachments" ON storage.objects FOR SELECT USING (
  bucket_id = 'ticket-attachments' AND auth.uid() IS NOT NULL
);

-- =====================================================
-- FIN DEL SCHEMA COMPLETO
-- =====================================================
